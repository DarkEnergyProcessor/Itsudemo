/**
* TEXBPixel.cpp
* Copy operation of various Byte/Pixel types for TEXB
*
* Part of http://github.com/summertriangle-dev/hatedelay with minor edits to suit libtexb
* License of this (and the original) code are below
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* 
* 1. Redistributions of source code must retain the above copyright notice, this
*    list of conditions and the following disclaimer. 
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the documentation
*    and/or other materials provided with the distribution.
* 3. The output of the software, and the software itself, will not be used
*    for financial gains. This includes, but is not limited to, charging to
*    view output generated by the software, charging for source code or object
*    code, displaying the output generated by the software/offering the software
*    for download alongside advertisements, etc.
* 
* THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR
* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
**/

#include "TEXB.h"

#include <algorithm>

#include <cstring>

#include <stdint.h>

/* implementations dubious? it is not care either way. */
void copy_1bpp_luma(uint8_t *raw, int len, uint8_t *output) {
	memset(output, 255, len * 4);
	for (int i = 0, ctr = 0; i < len; ctr = (++i) * 4) {
		output[ctr] = raw[i];
		output[ctr + 1] = raw[i];
		output[ctr + 2] = raw[i];
	}
}

void copy_1bpp_alpha(uint8_t *raw, int len, uint8_t *output) {
	memset(output, 0, len * 4);
	for (int i = 0, ctr = 0; i < len; ctr = (++i) * 4) {
		output[ctr + 3] = raw[i];
	}
}

void copy_2bpp_lumalpha(uint8_t *raw, int len, uint8_t *output) {
	memset(output, 0, len * 4);
	for (int i = 0, ctr = 0; i < len; ctr = (i += 2) * 4) {
		output[ctr] = raw[i];
		output[ctr + 1] = raw[i];
		output[ctr + 2] = raw[i];
		output[ctr + 3] = raw[i + 1];
	}
}

void copy_2bpp_rgb565(uint8_t *raw, int len, uint8_t *output) {
	memset(output, 255, len * 4);
	unsigned short *pixels = (unsigned short *) raw;
	for (int i = 0, ctr = 0; i < len; ctr = (++i) * 4) {
		unsigned short pixel = pixels[i];
		uint8_t shift = (pixel & 0xF800) >> 8;
		output[ctr] = shift | (shift >> 5);
		shift = (pixel & 0x07E0) >> 3;
		output[ctr + 1] = shift | (shift >> 6);
		shift = (pixel & 0x001F) << 3;
		output[ctr + 2] = shift | (shift >> 5);
	}
}

void copy_2bpp_rgba5551(uint8_t *raw, int len, uint8_t *output) {
	unsigned short *pixels = (unsigned short *) raw;
	for (int i = 0, ctr = 0; i < len; ctr = (++i) * 4) {
		unsigned short pixel = pixels[i];
		uint8_t shift = (pixel & 0xF800) >> 8;
		output[ctr] = shift | (shift >> 5);
		shift = (pixel & 0x07C0) >> 3;
		output[ctr + 1] = shift | (shift >> 5);
		shift = (pixel & 0x003E) << 2;
		output[ctr + 2] = shift | (shift >> 5);
		output[ctr + 3] = (pixel % 2)? 255 : 0;
	}
}

void copy_2bpp_rgba4444(uint8_t *raw, int len, uint8_t *output) {
	unsigned short *pixels = (unsigned short *) raw;
	for (int i = 0, ctr = 0; i < len; ctr = (++i) * 4) {
		unsigned short pixel = pixels[i];
		uint8_t shift = (pixel & 0xF000) >> 8;
		output[ctr] = shift | (shift >> 4);
		shift = (pixel & 0x0F00) >> 4;
		output[ctr + 1] = shift | (shift >> 4);
		shift = pixel & 0x00F0;
		output[ctr + 2] = shift | (shift >> 4);
		shift = pixel & 0x000F;
		output[ctr + 3] = shift | (shift << 4);
	}
}

void copy_3bpp_rgb(uint8_t *raw, int len, uint8_t *output) {
	memset(output, 255, len * 4);
	for (int i = 0, ctr = 0; i < len; ctr = (i += 3) * 4) {
		output[ctr] = raw[i];
		output[ctr + 1] = raw[i + 1];
		output[ctr + 2] = raw[i + 2];
	}
}

void convert_map(uint8_t *raw, uint32_t w, uint32_t h, uint16_t texb_flags, uint8_t *output) {
	convert_map(raw, w, h, TEXB_GET_CHANNEL_KIND(texb_flags), TEXB_GET_PIXEL_FORMAT(texb_flags), output);
}

void convert_map(uint8_t *raw, uint32_t w, uint32_t h, TEXB_CHANNEL_KIND img_format, TEXB_PIXEL_FORMAT pix_format, uint8_t *output) {
	switch (pix_format) {
		case TEXB_PIXEL_FORMAT_BYTE: {
			switch (img_format) {
				case TEXB_CHANNEL_KIND_LUMINANCE:
					copy_1bpp_luma(raw, w * h, output);
					break;
				case TEXB_CHANNEL_KIND_ALPHA:
					copy_1bpp_alpha(raw, w * h, output);
					break;
				case TEXB_CHANNEL_KIND_LUMINANCE_ALPHA:
					copy_2bpp_lumalpha(raw, w * h, output);
					break;
				case TEXB_CHANNEL_KIND_RGB:
					copy_3bpp_rgb(raw, w * h, output);
					break;
				case TEXB_CHANNEL_KIND_RGBA:
					memcpy(output, raw, w * h * 4);
					break;
				default:
					break;
			}

			break;
		}
		case TEXB_PIXEL_FORMAT_RGB565:
			copy_2bpp_rgb565(raw, w * h, output);
			break;
		case TEXB_PIXEL_FORMAT_RGBA5551:
			copy_2bpp_rgba5551(raw, w * h, output);
			break;
		case TEXB_PIXEL_FORMAT_RGBA4444:
			copy_2bpp_rgba4444(raw, w * h, output);
			break;
		default:
			break;
	}
	
	return;
}

UVPoint xy2uv(uint32_t x,uint32_t y,Point v0,Point v1,Point v2,Point v3,UVPoint t0,UVPoint t1,UVPoint t2,UVPoint t3)
{
	uint32_t xyw=abs(int(
		std::max(v0.X,std::max(v1.X,std::max(v2.X,v3.X))) -
		std::min(v0.X,std::min(v1.X,std::min(v2.X,v3.X)))
	));
	uint32_t xyh=abs(int(
		std::max(v0.Y,std::max(v1.Y,std::max(v2.Y,v3.Y))) -
		std::min(v0.Y,std::min(v1.Y,std::min(v2.Y,v3.Y)))
	));
	double atotal=xyw*xyh;
	double a0 = (x - v0.X) * (y - v0.Y) / atotal;
	double a1 = (v1.X - x) * (y - v1.Y) / atotal;
	double a2 = (v2.X - x) * (v2.Y - y) / atotal;
	double a3 = (x - v3.X) * (v3.Y - y) / atotal;
	UVPoint ret;

	ret.U=t2.U * a0 + t3.U * a1 + t0.U * a2 + t1.U * a3;
	ret.V=t2.V * a0 + t3.V * a1 + t0.V * a2 + t1.V * a3;

	return ret;
}

size_t GetBytePerPixel(uint16_t TexbFlags)
{
	uint8_t iff=TexbFlags&7;
	return GetBytePerPixel(iff, uint8_t(TexbFlags)>>6);
}

size_t GetBytePerPixel(uint8_t chankind, uint8_t pixfmt)
{
	switch(pixfmt)
	{
		case 0:
		case 1:
		case 2:
			return 2;
		case 3:
		{
			// [0] ALPHA | [1] LUMA | [2] LUMALPHA | [3] RGB | [4] RGBA
			switch(chankind)
			{
			case 0:
				return 1;
			default:
				return chankind;
			}
		}
		default:
			return 0;
	}
}
